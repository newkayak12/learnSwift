import UIKit

/**
    > 인스턴스 생성과 소멸
 구조체와 클래스를 생성할 때는 지금까지 기본 이니셜라이저를 사용해서 인스턴스를 생성했다. 초기화(Initialization)는 클래스나 구조체 또는 열거형의 인스턴스를 사용하기 위한 준비 과정이다. 초기화가 완료된 인스턴스는 사용 후 소멸 시점이 오면 소멸한다. 이번 장에서는 인스턴스를 생성하는 방법과 클래스의 인스턴스가 소멸할 때 어떤 프로세스가 진행되는지 알아보자
 
    1. 인스턴스의 생성
 초기화 과정은 새로운 인스턴스를 사용할 준비를 하기 위하여 저장 프로퍼티의 초기값을 설정하는 드으이 일을 한다. 이니셜라이저를 정의하면 초기화 과정을 직접 구현할 수 있다. 그렇게 구현된 이니셜라이저는 새로운 인스턴스를 생성할 수 있는 특별한 메소드가 된다. 스위프트의 이니셜라이저는 반환 값이 없다. 이니셜라이저의 역할은 그저 인스턴스의 첫 사용을 위해 초기화하는 것뿐이다.
 이니셜라이저는 해당 타입의 새로운 인스턴스를 생성하기 위해서 호출한다. 이니셜라이저는 func 키워드를 사용하지 않고 오로지 init 키워드를 사용하여 이니셜라이저 메소드임을 표현한다. init 메소드는 클래스, 구조체, 열거형 등의 구현부 또는 해당 타입의 익스텐션 구현부에 위치한다. 다만 클래스의 지정 이니셜라이저는 익스텐션해서 구현해줄 수 없다.
 */
class initClass{
    init(){
        
    }
}

struct initStruct{
    init(){
        
    }
}

enum initEnum{
    case someCase
    init(){
        //열거형은 초기화할 때 반드시 cas 중 하나가 되어야한다.
        self = .someCase
    }
}
/**
    1.1 프로퍼티 기본값
 구조체와 클래스의 인스턴스는 처음 생성할 떄 옵셔널 저장 프로퍼티를 제외한 모든 저장 프로퍼티에 적절한 초기값(initial Value)을 할당해야한다. 이니셜라이저 실행될 때 저장 프로퍼티에 적절한 초기 값을 할당할 수 있다. 초기화 후에 값이 확정되지 않은 저장 프로퍼티는 존재할 수 없다. 프로퍼티를 정의할 때 프로퍼티 기본값(Default Value)를 할당하면 이니셜라이저에서 따로 초기값을 할당하지 않더라도 프로퍼티 기본값으로 저장 프로퍼티의 값이 초기화 된다.
 
    {
            초기화 프로퍼티 옵저버
        이니셜라이저를 통해 초기값을 할당하거나, 프로퍼티 기본값을 통해 처음의 저장 프로퍼티가 초기화 될때는 프로퍼티 감시자 메소드가 호출되지 않는다.
    }
 */

struct Area{
    var squareMeter: Double
    init(){
        squareMeter = 0.0//initValue
    }
}

let room: Area = Area()
print(room.squareMeter)

/**
 구조체 Area는 squareMeter라는 Double 타입의 저장 프로퍼티를 가지고 있다. init 이니셜라이저로 인스턴스를 초기화하며 squareMeter의 초기값은 0.0이 된다.
 앞서 설명했듯이 이니셜라이저로 저장 프로펕티에 초기값을 설정하는 방법도 있지만, 프로퍼티를 정의할 때 프로퍼티에 기본값을 할당하는 방식을 사용할 수도 있다. 프로퍼티에 기본 값을 할당 하는 방법은 아래와 같다.
 */

struct Area2{
    var squareMeter: Double = 0.0
}
let room2: Area2 = Area2()
print(room.squareMeter)
/**
 초기화 과정은 이니셜라이저의 매개변수, 옵셔널 프로퍼티, 상수 프로퍼티의 값 할당 등 프로그래머의 의도대로 구현할 수 있는 다양한 패턴의 이니셜라이저가 있다.
 
 
 
    1.2 이니셜라이저 매개변수
 함수나 메소드를 정의할 때와 마찬가지로 이니셜라이저도 매개변수를 가질 수 있다. 즉, 인스턴스를 초기화하는 과정이 필요한 값을 전달할 수 있다.
 */
struct Area3 {
    var squareMeter: Double
    init(fromPy py: Double){
        self.squareMeter = py * 3.3058
    }
    init(fromSqaureMeter squareMeter: Double){
        self.squareMeter = squareMeter
    }
    init(value: Double){
        self.squareMeter = value
    }
    init(_ value: Double){
        self.squareMeter = value
    }
}

let roomOne: Area3 = Area3(fromPy: 15.0)
print(roomOne)
let roomTwo: Area3 = Area3(fromSqaureMeter: 33.06)
print(roomTwo)

let roomThree: Area3 = Area3(value: 33.06)
let roomFour: Area3 = Area3(33.06)

//Area3() // error
/**
위와 같이 사용자 정의 이니셜라이저를 만들면 기존의 기본 이니셜라이저(init())는 별도로 구현하지 않는 이상 사용할 수 없다. 세번쨰 이니셜라이저는 따로 전달 인자를 사용하지 않았다. 별다른 의미 없는 value 라는 이름의 매개변수가 있으므로 만약 자동으로 지정되는 전달인자 레이블 value가 필요하지 않다면 네 번쨰 이니셜라이저처럼 와일드 카드 식별자(_)를 사용하여 전달인자 레이블을 없애주면 된다.
 
 
    1.3 옵셔널 프로퍼티 타입
 초기화 과정에서 값을 초기화하지 않아도 되는, 즉 인스턴스가 사용되는 동안에 값을 꼭 갖지 않아도 되는 저장 프로퍼티가 있다면 해당 프로퍼티를 옵셔널로 선언할 수 있다. 또는 초기화 과정에서 값을 지정해주기 어려운 경우 저장 프로퍼티를 옵셔널로 선언할 수도 있다. 옵셔널로 선언한 저장 프로퍼티는 초기화 과정에서 값을 할당해주지 않는다면 자동으로 nil이 할당된다.
 */
class Person {
    var name: String
    var age: Int?
    
    init(name: String){
        self.name = name;
    }
}

let yj: Person = Person(name: "yj")
print(yj.name)

print(yj.age)

yj.age = 99
print(yj.age)

yj.name = "SH"
print(yj.name)

/**
 옵셔널로 할당하면 이니셜라이저에서 특별히 초기화 하지 않았지만 자동으로 nil이 할당되어 있다.
 
 
    1.4 상수 프로퍼티
 위 예시에서 이름 프로퍼티를 상수가 아닌 변수로 선언해둔다면 재할당으로 값이 바뀔 수 있다. 이런 상황을 방지하려면 해당 프로퍼티를 상수로 선언해야한다. 그러나 상수로 선언된 저장 프로퍼티는 인스턴스를 초기화하는 과정에서만 값을 할당할 수 있으며, 처음 할당된 이후로는 값을 변경할 수 없다.
    {
            상수 프로퍼티와 상속
        클래스 인스턴스의 상수 프로퍼티는 프로퍼티가 정의된 클래스에서만 초기화할 수 있다. 해당 클래스를 상속받은 자식 클래스의 이니셜라이저에서는 부모클래스의 상수 프로퍼티 값을 초기화할 수 없다.
    }
 */
class Person2{
    let name: String;
    var age: Int?
    init(name: String){
        self.name = name
    }
}
let yj2: Person2 = Person2(name: "YJ")
//yj12.name = "ERIC" //Error

/**
 
    1.5 기본 이니셜라이저와 멤버 와이즈 이니셜라이저
 이제까지 사용자 정의 이니셜라이저에 대해 알아봤는데, 정작 기본 이니셜라이저에 대해서 알아보지 못했다. 사용자 정의 이니셜라이저를 정의해주지 않으면 클래스나 구조체는 모든 프로퍼티에 기본값이 지정되어 있자는 전제 하에 기본 이니셜라이저를 사용한다. 기본 이니셜라이저는 프로퍼티 기본값으로 프로퍼티를 초기화해서 인스턴스를 생성한다. 즉, 기본 이니셜라이저는 저장 프로퍼티의 기본값이 모두 지정되어있고, 동시에 사용자 정의 이니셜라이저가 정의되어 있지 않은 상태에서 제공된다. 저장 프로퍼티를 선언할 때 기본값을 지정해주지 않으면 이니셜라이저에서 초깃ㄱ밧을 설정해야한다. 그러나 프로퍼티 하나 때문에 매번 이니셜라이저를 추가하거나 변경하는 일은 여간 귀찮은 일이 아니다. 때문에 구조체는 사용자 정의 이니셜라이저를 구현하지 않으면 프로퍼티의 이름으로 매개변수를 갖는 이니셜라이저인 멤버와이즈 이니셜라이저를 기본으로 제공한다. 그렇지만 클래스는 멤버와이즈 이니셜라이저를 지원하지 않는다.
 */
//구조체가 멤버와이즈 이니셜라이즈 사용
struct Point{
    var x: Double = 0.0
    var y: Double = 0.0
}
struct Size{
    var width: Double = 0.0
    var height: Double = 0.0
}

let point: Point = Point(x: 0, y: 0)
let size: Size = Size(width: 50.0, height: 50.0)

//구조체 프로퍼티에 기본값이 있다면 필요한 매개변수만 사용하여 초기화할 수도 있다.
//let somePoint: Point = Point()
//let someSize: Size = Size(width: 50)
//let anotherPoint: Point = Point(y:100)
/**
    1.6 초기화 위임
 값 타입인 구조체와 열거형은 코드의 중복을 피하기 위해서 이니셜라이저가 아닌 이니셜라이저에게 일부 초기화를 위임하는 초기화 위임을 간단하게 구현할 수 있다. 하지만 클래스는 상속을 지원하는터라 간단한 초기화 위임도 할 수 없다.
 값 타입에서 이니셜라이저가 아른 이니셜라이저를 호출하려면 self.init을 사용한다. 당연히 self.init은 이니셜라이저 안에서만 사용할 수 있는데, self.init을 사용한다는 것 자체가 사용자 정의 이니셜라이저를 정의하고 있다는 뜻이다. 그런데 사용자 정의 이니셜라이저를 정의하면 기본 이니셜라이저와 멤버와이즈 이니셜라이저를 사용할 수 없다고 했다. 따라서 초기화 위임을 하려면 최소 두 개 이상의 사용자 정의 이니셜라이저를 정의해야한다.
    {
            기본 이니셜라이저를 지키고 싶다면
        사용자 정의 이니셜라이저를 정의할 때도 기본 이니셜라이저나 멤버 와잉즈 이니셜라이저를 사용하고 싶으면 잉ㄱ스텐션을 이용해서 사용자 정의 이니셜라이저를 구현하면 된다. 
    }
 */
