/**
                > ARC
 
 매번 전달할 때마다 값을 복사해 전달하는 값 타입과는 달리 참조 타입은 하나의 인스턴스가 참조를 통해 여러 곳에 접근하기 때문에 언제 메모리에서 해제되는지가 중요한 문제이다.
 인스턴스가 적절한 시점에 메모리에서 해제되지 않으면 한정적인 메모리 자원을 낭비하게 되며, 이는 성능의 저하로 이어지게 된다. 스위프트는 프로그램의 메모리 사용을 곤리하기 위해서 메모리 관리 기법인 ARC를 사용한다.
 
     {
            ARC와 값 타입
        ARC가 관리해주는 참조 횟수 계산(Reference Counting)은 참조 타입인 클래스의 인스턴스에만 적용된다. 구조체나 열거형은 값 타입이므로 참조 횟수 계산과 무관하다. 즉, 구조체나 열거형은 다른 곳에서 참조하기 때문에 ARC로 관리할 필요가 없다.
        
     }
 
                1. ARC(Automatic Reference Counting)란?
 ARC 기능은 자동으로 메모리를 관리해주는 방식이다. 아무래도 프로그래머가 메모리 관리에 신경을 덜 쓸수 있기 때문에 편리하다. ARC는 더 이상 필요하지 않은 클래스의 인스턴스를 메모리에서 해제하는 방식으로 동작한다. 그렇다면 자바 등 다른 프로그래밍에서 사용하는 메모리 관리 기법인 가비지컬렉션(GC)와는 어떤 차이가 있을까?
 
 ARC와 가비지 컬렉션은 참조를 계산하는 시점이다. ARC는 인스턴스가 언제 메모리에서 해제되어야 할지를 컴파일과 동시에 결정하지만 가비지컬렉션은 그렇지 않다.
 
    메모리 관리 기법                   ARC                                             가비지 컬렉션
    참조 카운팅 시점                 컴파일 시                                              런타임
    장점                  컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어               상호 참조 상황 등 복잡한 상황에서도 인스턴스를 해제할 수 있는
                       인스턴스가 언제 메모리에서 해제되는지 예측이 가능                  가능성이 더 높다.
                    
                         컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어               특별히 규칙에 신경 쓸 필요가 없다.
                        메모리 관리를 위한 시스템 자원을 추가할 필요가 없다.
    
    단점                  ARC의 작동 규칙을 모르고 사용하면 인스턴스가                    프로그램 동작 외에 메모리 감시를 위한 추가 자원이 필요하므로 한정적인
                        메모리에 영원히 해제되지 않을 수 있다.                         자원 환경에서는 성능 저하가 발생할 수 있다.
                                                            
                                                                               명확한 규칙이 없어서 인스턴스가 언제 해제될지 예측할 수 없다.
 
 
 ARC를 이용해서 자동으로 메모리 관리를 받기 위해서는 몇 가지 규칙을 알아야 한다. 왜냐하면 가비지 컬렉션과 달리 ARC는 컴파일과 동시에 인스턴스를 메모리에 해제하는 시점이 결정하기 때문이다. 우리가 원하는 방향으로 메모리 관리가 이뤄지려면 ARC에 명확한 힌트를 줘야한다.
 
 클래스의 인스턴스를 생성할 때마다 ARC는 그 인스턴스에 대한 정보를 저장하기 위한 메모리 공간을 또 따로 할당한다. 그 메모리 공간에는 인스턴스 타입 정보와 함께 그 인스턴스와 관련된 저장 프로퍼티의 값을 저장한다. 그 후에 인스턴스가 더 이상 필요 없는 상태가 되면 인스턴스가 차지하던 메모리 공간을 다른 용도로 활용할 수 있도록 ARC가 메모리에서 인스턴스를 없앤다.
 
 그런데 만약 아직 더 사용해야 하는 인스턴스를 메모리에서 해제시킨다면 인스턴스와 관련된 프로퍼티에 접근하거나 인스턴스의 메소드를 호출할 수 없다. 게다가 인스턴스에 강제로 접근하려고 하면 잘못된 메모리 접근으로 인해 프로그램이 강제 종료될 확률이 크다.
 
 인스턴스가 지속해서 필요한 상황에서 ARC는 인스턴스가 메모리에서 해제되지 않도록 인스턴스 참조 여부를 계속 추적한다. 다른 인스턴스의 프로퍼티나 변수, 상수 등 어느 한 곳에서 인스턴스를 참조한다면 ARC가 해당 인스턴스를 해제하지 않고 유지해야하는 명분이 된다. 인스턴스를 메모리에 유지시키려면 이런 명분을 ARC에 제공해야 한다는 것을 명심해야한다.
 
 인스턴스가 언제 메모리에서 해제될지 예측할 수 있도록 ARC에 적용되는 몇 가지 규칙을 알아보자. 그리고 규칙을 알지 못할 때 벌어질 수 있는 문제점, 해결방안도 같이 알아보자
 
 
 
 
                    2. 강한참조
 인스턴스가 계속해서 메모리에 남아있어야 하는 명분을 만들어 주는 것이 바로 강한참조(Strong Reference)이다. 인스턴스는 참조 횟수가 0이 되는 순간 메모리에서 해제되는데, 인스턴스를 다른 인스턴스의 프로퍼티나 변수, 상수 등에 할당할 때 강한 참조를 사용하면 참조 횟수가 1 증가한다. 또, 강한 참조를 사용하는 프로퍼티, 변수, 상수 등에 nil을 할당하면 원래 자신에게 할당되어 있던 인스턴스의 참조 횟수가 1 감소한다.
 
 참조의 기본은 강한 참조이므로 클래스 타입의 프로퍼티, 변수, 상수 등을 선언할 때 별도의 식별자를 명시하지 않으면 강한 참조를 한다. 이제까지 우리는 알지 못하고 써왔지만 프로퍼티와 변수, 상수를 모두 강한 참조로 선언해주었던 것이다.
 */
//강한참조와 참조 횟수 확인
class Person {
    let name: String
    
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}
var reference1: Person?
var reference2: Person?
var reference3: Person?

reference1 = Person(name: "YJ") //참조 횟수 == 1
reference2 = reference1 //참조 횟수 == 2
reference3 = reference1 //참조 횟수 == 3

reference3 = nil //참조횟수 == 2
reference2 = nil //참조횟수 == 1
reference1 = nil //참조횟수 == 0
/**
 reference1은 메모리에 할당 후 강한 참조로 Person이 할당되므로 참조 횟수가 1 증가한다. reference2, 3에 강한 참조로 참조되므로 참조 횟수가 1씩 증가한다.
 따라서 메모리에 살아있을 명분이 충분하다. reference 3, 2, 1순으로 참조가 해제되면서 참조 횟수가 1씩 감소하고 참조가 0 이되면서 인스턴스는 ARC 규칙에 따라 메모리에서 해제되며, 메모리에서 해제되기 직전 디이니셜라이저를 호출한다.
 */

func foo() {
    let yj = Person(name: "YJ in Func")
    //함수 종료 시점이 되면서 디 이니셜라이징 된다.
}
foo()
/**
  foo() 안에 강한 참조 상수가 있다. yj에 할당된 후 참조 횟수가 + 1이 되며, 지역변수 스코프가 끝나면서 참조 횟수가 1 감소한다.
 */

var globalReference: Person?
func foo2() {
    let localReference: Person = Person(name: "local")
    globalReference = localReference
    
    //전역에 참조되었기 때문에 디이니셜라이즈 되지 않는다.
}
foo2()
/**
 지역 변수가 전역변수에서 참조 되었기 때문에 디이니셜라이징 되지 않는다.
 
 
                2.1 강한 순환 참조 문제
 그런데 복합적으로 강한 참조가 일어나는 상황에서 강한 참조의 규칙을 모르고 사용하게 되면 문제가 발생할 수 있다. 인스턴스끼리 서로가 서로를 강한 참조할 때를 대표적인 예로 들 수 있다. 이를 강한 순환 참조(Strong Refernce Cycle)이라고 한다.
 */
class Persons {
    let name: String
    init(name: String){
        self.name = name
    }
    var room: Room?
    deinit{
        print("\(name) is being deinitialized")
    }
}

class Room {
    let number: String
    init(number: String){
        self.number = number
    }
    var host: Persons?
    deinit {
        print("Room \(number) is being deinitialized")
    }
}

var yagom: Persons? = Persons(name: "yagom") //인스턴스 참조 횟수 1
var room: Room? = Room(number: "505") //인스턴스 참조 횟수 1

room?.host = yagom //인스턴스 참조 횟수 2
yagom?.room = room //인스턴스 참조 횟수 2

yagom = nil //인스턴스 참조 횟수 1
room = nil //인스턴스 참조 횟수 1

//Persons, Room 인스턴스를 참조할 방법을 잃었지만 메모리에 잔존하고 있다.
/**
    Person 클래스는 강한 참조를 하는 Room? 타입의 저장 프로퍼티 room을 가지고 있으며, Room 클래스는 강한참조를 하는 Person? 타입의 저장 프로퍼티 host를 갖는다. 이 둘은 모두 옵셔널이며 메모리에서 해제되는 순간을 감지하기 위해서 디이니셜라이저를 갖고 있다. 그러나 이 둘은 영원히 디이니셜라이저가 호출되지 않는다.
 
    서로 강한 참조를 하는 상태에서 각 변수에 nil을 선언해도 각 인스턴스 내부에서 서로를 강한 참조하고 있어 메모리에서 해제되지 않는다. 이렇게 메모리 누수가 발생한다.
    이렇게 두 인스턴스가 서로를 참조하는 상황에서 강한 참조 순환 문제가 발생할 수 있다.
 
 */
//수동으로 강한 순환 참조 해결
var manualYagom: Persons? = Persons(name: "mYagom")
var manualRoom: Room? = Room(number: "203")

manualRoom?.host = manualYagom
manualYagom?.room = manualRoom

manualYagom?.room = nil
manualYagom = nil

manualRoom?.host = nil
manualRoom = nil

/**
    변수 또는 프로퍼티에 nil을 할당하면 참조 횟수가 감소한다는 규칙을 생가하면 위와 같은 방법으로 인스턴스를 메모리에서 해제시킬 수 있을지 모른다. 더 우아한 해결책은 없을까?
    약한 참조, 미소유 참조를 통해 더 명확한 해결책을 찾아보자
 
 
 
                3. 약한 참조
    약한 참조(Weak Reference)는 강한 참조와 달리 자신이 참조하는 인스턴스의 참조 횟수를 증가시키지 않는다. 참조 타입의 프로퍼퍼티나 변수 선언 앞에 weak를 써주면 그 프로퍼티나 변수는 자신이 참조하는 인스턴스를 약한 참조한다.
 
    약한 참조를 사용한다면 자신이 참조하는 인스턴스가 메모리에서 해제될 수도 있다는 것을 예상해볼 수 있어야한다. 자신이 참조 횟수를 증가시키지 않았기 때문에 그 인스턴스를 강한 참조하던 프로퍼티나 변수에서 참조 횟수를 감소시켜 0으로 만들면 자신이 참조하던 인스턴스가 메모리에서 해제되기 떄문이다.
 
    {
                약한 참조와 상수, 옵셔널
        약한 참조는 상수에서 쓰일 수 없다. 만약 자신이 참조하던 인스턴스가 메모리에서 해제된다면 nil이 할당될 수 있어야하기 때문이다. 그래서 약한 참조를 할 때는 자신의 값을 변경할 수 있는 변수로 선언해야한다. 더불어 nil이 할당될 수도 있으므로, 약한 참조는 항상 옵셔널이어야한다. 즉, 옵셔널 변수만 약한 참조를 할 수 있다.
    }
 */
//강한 참조 순환 문제를 약한 참조로 해결
class Room1 {
    let number: String
    init(number: String) {
        self.number = number
    }
    
    weak var host: Person1?
    
    deinit {
        print("Room \(number) is being deinit")
    }
}
class Person1 {
    let name: String
    init(name: String){
        self.name = name
    }
    var room: Room1?
    deinit{
        print("\(name) is being deinitialized")
    }
}


var yygom: Person1? = Person1(name: "YGOM") //Person1 참조 횟수 : 1
var rroom: Room1? = Room1(number: "505") //Room1 참조 횟수 : 1

rroom?.host = yygom  //Person1 참조 횟수 : 1
yygom?.room = rroom  //Room1 참조 횟수 : 2

yygom = nil // Person 참조 횟수 : 0 Room 참조 횟수 : 1
print(rroom?.host) //nil

rroom = nil // Room 참조 0
/**
  강한 순환 참조를 해결하기 위해서 Room 클래스의 host 프로퍼티가 약한 참조를 하도록 weak 키워드를 추가해서 정의했다. 각각의 Person, Room 은 변수에 할당할 때 참조 횟수가 1 증가하는 것은 이전과 같다. 그러나 room 변수가 참조하는 인스턴스의 host 프로퍼티가 약한 참조를 하므로 yygom을 room의 host가 참조하도록 할 때 참조 횟수가 증가하지 않는다. 그러나 반대의 경우는 참조 횟수가 증가한다.
 
  여기서 yygom이 참조했던 인스턴스의 참조 횟수가 0이되면서 메모리에서 해제될 때 인스턴스의 room 프로퍼티가 참조하는 인스턴스 참조 횟수도 1 감소한다. 이를 통해서 메모리에서 인스턴스가 해제될 때, 자신의 프로퍼티가 강한 참조를 하던 인스턴스의 참조 횟수르 1 감소시킨다는 것을 알 수 있다.
 
  그리고 yygom이 참조하던 인스턴스가 메모리에서 해제됐다는 것은 room이 참조하는 인스턴스 프로퍼티인 host 가 참조하는 인스턴스가 메모리에서 해제되었다는 의미이다. host 프로퍼티는 약한 참조를 하기 때문에 자신이 참조하는 인스턴스가 메모리에서 해제되면 자동으로 nil을 할당한다는 것을 알 수 있다.
 
  그리고 마지막으로 room이 참조하던 인스턴스는 room = nil로 자신을 참조하는 곳이 없어지고 참조 횟수가 0이 되며, 메모리에서 해제된다.
 
 
 
 
            4. 미소유 참조 
 */
