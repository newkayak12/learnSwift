import Foundation
/**
    클로저
 스위프트에서 함수형 프로그래밍 패러다임을 접할 때 꼭 알아야하는 개념이 클로저(closure)이다. 클로저를 잘 이해해야 스위프트 함수형 프로그래밍 패러다임 스타일을 조금 더 명확하게 이해할 수 있다. 클로저와 제네릭(Generics), 프로토콜(Protocol), 모나드(Monad) 등이 결합해서 스위프트는 훨씬 강력한 언어가 되었다.
 
 스위프트의 클로저는 C언어나 Objective-C의 블록(block) 또는 다른 프로그래밍언어의 람다(Lambda)와 유사하다. 클로저는 일정 기능을 하는 코드를 하나의 블록으로 모아놓은 것을 말한다. 어딘가 함수와 비슷해보이는데 사실 함수는 클로저의 한 형태이다.
 
 클로저는 변수나 상수가 선언된 위치에서 참조(Reference)를 획득(Capture)하고 저장할 수 있다. 이를 변수나 상수의 클로징(잠금)이라고 하며 클로저는 여기서 착안된 이름이다. 획득 때문에 메모리에 무리가 가지 않을까 하지만 스위프트는 알아서 메모리를 관리한다.
 
 클로저의 몇 가지 모양 중 하나가 함수이다. 조금 더 자세히 보면 세 가지 형태가 있다.
 
    1. 이름이 있으면서 어떤 값도 획득하지 않는 전역함수 형태
    2. 이름이 있으면서 다른 함수의 내부의 값을 획득할 수 있는 중첩된 함수 형태
    3. 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법 형태
 
 클로저 문법 전, 클로저의 장점을 나열하면
 
    1. 클로저는 매개변수와 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 매개변수와 반환 값의 타입을 생략할 수 있다.
    2. 클로저에서 단 한 줄의 표현만 들어있다면 암시적으로 이를 반환 값으로 취급한다.
    3. 축약된 전달인자 이름을 사용할 수 있다.
    4. 후행 클로저 문법을 사용할 수 있다.
 
 이전의 '중첩함수'는 함수 안에 함수가 포함된 하나의 클로저 형식이었다. 그런데 함수를 중첩하여 사용하기보다는 조금 더 간단한 형태로 함수처럼 사용하고 싶을 수 있고 또는 함수 내부에서 다른 함수를 사용할 때 내부 함수에 이름을 붙일 필요가 없을 수도 있다. 이런 여러 가지 경우에 함수 또는 메소드의 전달인자로 함수를 받아오면 된다.
 클로저 표현 방법은 클로저가 함수의 모습이 아닌 하나의 블록의 모습으로 표현될 수 있는 방법을 의미한다. 클로저 표현 방법은 클로저의 위치를 기준으로 크게 기본 클로저 표현과 후행 클로저 표현이 있다. 또, 각 표현 내에서 가독성을 해치지 않는 선에서 표현을 생략하거나 축약할 수도 있다.
 
 
 
 
        1. 기본 클로저
 스위프트 표준 라이브러리에는 배열의 값을 정렬하기 위해서 sorted(by:) 메소드가 있다. 이 메소드는 클로저를 통해서 어떻게 정렬할 것인가에 대한 정보를 받아 처리하고 결과 값을 배열로 돌려준다. 단순히 정렬만 하기 때문에 입력받은 배열의 타입과 크기가 동일하다. 기존의 배열을 변경하지 않고 정렬된 배열을 새로 생성하여 반환해준다.
 
 --
    public func sorted(by areInIncreasingOrder: (Element, Element) -> Bool) -> [Element]
 --
 */
let names: [String] = ["YJ", "SH", "WS", "TH"]
/**
    sorted(by:) 메소드는(배열의 타입과 같은 두 개의 매개변수를 가지며, Bool 타입을 반환하는) 클로저를 전달인자로 받을 수 있다. 반환하는 Bool 값은 첫 번쨰 전달인자 값이 새로 생성되는 배열에서 두 번째 전달인자 값보다 먼저 배치 되어야하는가에 대한 결과 값이다. true이면 첫 번쨰 전달인자가 두 번쨰 전달인자 앞에 온다.
 
    우선은 우리가 익숙한대로 String 두 개를 가지며, Bool을 반환하는 함수를 구현해보자 그 후 이를 sorted(by:)의 전달인자로 전달하여 reversed라는 이름의 배열로 반환 받는다.
 */
func backwards(first: String, second: String) -> Bool {
    print("\(first), \(second)")
    return first > second
}
let reversed: [String] = names.sorted(by: backwards)
print(reversed)

/**
    만약 first 문자열이 second 문자열보다 크다면 backwards(first:second:) 함수의 반환 값은 true가 된다. 즉, 값이 더 큰 first 문자열이 second 문자열보다 앞쪽에 정렬되어야한다는 것이다. 그러나 first > second라는 반환 값을 받기 위해 너무 많은 표현이 사용되었따. 함수 이름부터 매개변수 표현까지 부가적인 표현도 많다. 이를 클로저로 더 간결하게 표현해보자
 
    {
        ( 매개 변수들 ) -> 반환 타입 in
 
            실행 코드
    }
 
    클로저도 함수와 마찬가지로 입출력 매개변수를 사용할 수 있다. 매개변수 이름을 지정한다면 가변 매개변수 또한 사용 가능하다. 다만 클로저는 매개변수 기본값을 사용할 수 없다.
 */
let reversed2: [String] = names.sorted(by: { (first:String, second: String)-> Bool in return first > second})
print(reversed2)

/**
    이렇게 프로그래밍하면 sorted(by:) 메소드로 전달하는 backward(first:second:) 함수가 어디에 있는지, 어떻게 구현되어 있는지 찾아다니지 않아도 된다.
 
    
 
        2. 후행 클로저
    위 코드보다 조금더 클로저를 일기 쉽게 바꿔볼 수 있다. 함수나 메소드의 마지막 전달인자로 위치하는 클로저는 함수나 메소드 소괄호를 닫은 후 작성해도 된다. 클로저가 조금 길어진다거나 가독성이 떨어지면 후행 클로저(trailing closure) 기능을 사용하면 좋다. 
    
 */
